.data
# --- Configuração do Arquivo ---
nome_arquivo: .asciiz "C:\\AOC\\TRABALHO AOC\\batteryDataset.csv"

# Buffer aumentado para 150kb para caber o arquivo inteiro e evitar cortes
buffer: .space 150000  

# --- Mensagens e Formatação ---
text_abrir_sucesso: .asciiz "Arquivo aberto com sucesso!\nProcessando dados...\n"
text_abrir_falha: .asciiz "ERRO: Falha ao abrir o arquivo 'batteryDataset.csv'. Verifique se ele esta na mesma pasta.\n"
text_ler_sucesso: .asciiz "\n--- Leitura Concluida ---\nTotal de linhas de dados processadas: "

novo_array: .asciiz "\n\n=== COLUNA "
fecha_coluna: .asciiz " ===\n"
separador: .asciiz ", "
quebra_linha: .asciiz "\n"

# --- Arrays de Dados (Floats) ---
# Capacidade para 1000 linhas x 4 bytes cada = 4000 bytes por coluna
array_cycle: .space 4000 
array_chI:   .space 4000
array_chV:   .space 4000
array_chT:   .space 4000
array_disI:  .space 4000
array_disV:  .space 4000
array_disT:  .space 4000
array_BCt:   .space 4000
array_SOH:   .space 4000
array_RUL:   .space 4000

# Tabela de ponteiros para facilitar o acesso iterativo
ponteiros_arrays:
    .word array_cycle
    .word array_chI
    .word array_chV
    .word array_chT
    .word array_disI
    .word array_disV
    .word array_disT
    .word array_BCt
    .word array_SOH
    .word array_RUL

# --- Variáveis de Controle ---
contador_linhas: .word 0 
constante_10:    .float 10.0   # Usado para conversão decimal

.text
.globl main

main:
    # 1. ABRIR ARQUIVO
    li $v0, 13      
    la $a0, nome_arquivo  
    li $a1, 0       # Read-only
    li $a2, 0       
    syscall
    
    move $s0, $v0     # $s0 = File Descriptor
    
    blt $s0, 0, erro_abertura
    
    # Sucesso na abertura
    li $v0, 4
    la $a0, text_abrir_sucesso
    syscall
    
    # 2. LER ARQUIVO INTEIRO
    li $v0, 14
    move $a0, $s0
    la $a1, buffer
    li $a2, 150000    # Tamanho máximo de leitura
    syscall
    
    move $s2, $v0     # $s2 = Total de bytes lidos
    
    # Fecha o arquivo logo após ler (boas práticas)
    li $v0, 16
    move $a0, $s0
    syscall
    
    # Se leu 0 bytes, sai
    beq $s2, $zero, exit
    
    # Coloca um terminador nulo no final do buffer por segurança
    la $t0, buffer
    add $t0, $t0, $s2
    sb $zero, 0($t0)

    # --- INÍCIO DO PROCESSAMENTO ---
    la $s1, buffer    # $s1 = Ponteiro atual no buffer
    add $s5, $s1, $s2 # $s5 = Endereço final do buffer
    
    li $s3, 0         # $s3 = Índice da Coluna (0 a 10)
    
    # Pular a primeira linha (cabeçalho)
    # Loop simples para encontrar o primeiro \n
pular_cabecalho:
    lb $t0, 0($s1)
    addi $s1, $s1, 1
    beq $t0, 10, inicio_linha_dados # 10 é \n
    bge $s1, $s5, printar_arrays    # Se acabar o buffer, sai
    j pular_cabecalho

inicio_linha_dados:
    li $s3, 0         # Reinicia coluna para nova linha
    move $s4, $s1     # $s4 = Início do token atual

loop_parse:
    # Verifica fim do buffer
    bge $s1, $s5, fim_processamento
    
    lb $t0, 0($s1)    # Lê caractere atual
    
    # Verifica delimitadores: Vírgula (,) ou Nova Linha (\n) ou Fim de String (\0)
    beq $t0, 44, achou_token   # 44 = ,
    beq $t0, 10, achou_token   # 10 = \n
    beq $t0, 13, pular_char    # 13 = \r (ignorar)
    beq $t0, 0,  fim_processamento
    
    addi $s1, $s1, 1  # Avança ponteiro
    j loop_parse

pular_char:
    addi $s1, $s1, 1
    move $s4, $s1     # Ajusta início do token se for caractere inútil
    j loop_parse

achou_token:
    # Substitui o delimitador por \0 para formar uma string válida
    sb $zero, 0($s1)
    
    # Verifica se é a coluna 0 (battery_id "B5", "B7"). 
    # Se for, não convertemos para float, apenas ignoramos.
    beq $s3, $zero, proxima_coluna_logica
    
    # --- CONVERSÃO E SALVAMENTO ---
    move $a0, $s4     # $a0 = String do número (ex: "4254681794")
    move $a1, $s3     # $a1 = Índice da coluna (1 a 10)
    
    # Salva registradores S temporariamente
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    
    jal converter_e_salvar_float
    
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    # -----------------------------

proxima_coluna_logica:
    # Verifica qual foi o delimitador original (revertendo o \0 temporário ou verificando posição)
    # Mas como já processamos, apenas avançamos a lógica da coluna.
    
    addi $s3, $s3, 1  # Próxima coluna
    
    # Se passamos de 11 colunas, algo está estranho, mas resetamos no \n
    
    # Se o delimitador que parou o loop anterior era \n (agora é 0), finaliza a linha
    # Precisamos ver se o byte original era \n. Como sobrescrevemos com 0, olhamos a lógica:
    # O loop_parse parou. Avançamos $s1 para o próximo char.
    
    addi $s1, $s1, 1
    
    # Se chegamos na coluna 11 (ou achamos quebra de linha), incrementa linha
    li $t9, 11
    bne $s3, $t9, prepara_proximo_token
    
    # Fim da linha: Incrementa contador de linhas
    lw $t8, contador_linhas
    addi $t8, $t8, 1
    sw $t8, contador_linhas
    
    li $s3, 0 # Reseta coluna

prepara_proximo_token:
    move $s4, $s1 # Novo token começa aqui
    j loop_parse

fim_processamento:
    # Imprime estatísticas
    li $v0, 4
    la $a0, text_ler_sucesso
    syscall
    
    li $v0, 1
    lw $a0, contador_linhas
    syscall
    
    j printar_arrays

# -----------------------------------------------------------
# Função: converter_e_salvar_float
# Entrada: $a0 = String (ex: "4254..."), $a1 = Índice Coluna (1..10)
# -----------------------------------------------------------
converter_e_salvar_float:
    # 1. Converter String para Float (Algoritmo ATOF simplificado)
    #    Lê inteiro digito a digito e acumula em registrador Float
    
    l.s $f10, constante_10  # Carrega 10.0
    
    mtc1 $zero, $f0         # $f0 = 0.0 (Acumulador)
    cvt.s.w $f0, $f0        
    
    move $t0, $a0           # $t0 aponta para a string

loop_atof:
    lb $t1, 0($t0)          # Lê char
    beq $t1, $zero, fim_atof # Se \0, acabou
    
    # Verifica se é dígito '0' (48) a '9' (57)
    li $t2, 48
    li $t3, 57
    blt $t1, $t2, prox_char_atof
    bgt $t1, $t3, prox_char_atof
    
    sub $t1, $t1, $t2       # Converte ASCII '5' para int 5
    
    mtc1 $t1, $f1           # Move para Coproc
    cvt.s.w $f1, $f1        # Converte int 5 para float 5.0
    
    mul.s $f0, $f0, $f10    # Acumulador * 10
    add.s $f0, $f0, $f1     # Acumulador + Digito
    
prox_char_atof:
    addi $t0, $t0, 1
    j loop_atof

fim_atof:
    # Agora $f0 tem o valor float (ex: 4.2546817E9)
    # Não há overflow porque floats aguentam até 10^38.
    
    # 2. Calcular endereço de salvamento no array correto
    
    # Índice do Array = Coluna ($a1) - 1 (pois pulamos a 0)
    addi $t4, $a1, -1  
    
    # Carrega endereço base do array correto
    la $t5, ponteiros_arrays
    sll $t4, $t4, 2         # offset = indice * 4
    add $t5, $t5, $t4
    lw $t6, 0($t5)          # $t6 = Endereço inicial do Array X
    
    # Calcula deslocamento baseado na linha atual
    lw $t7, contador_linhas
    sll $t7, $t7, 2         # offset linha = linha * 4
    add $t6, $t6, $t7       # Endereço Final = BaseArray + OffsetLinha
    
    # Salva o float na memória
    swc1 $f0, 0($t6)
    
    jr $ra

# -----------------------------------------------------------
# Rotina de Impressão (Apenas para Debug/Visualização)
# -----------------------------------------------------------
printar_arrays:
    li $s6, 0             # Índice Coluna (0 a 9 arrays internos)
    lw $t9, contador_linhas
    la $s1, ponteiros_arrays

loop_print_col:
    li $t8, 10
    beq $s6, $t8, exit
    
    # Print Título
    li $v0, 4
    la $a0, novo_array
    syscall
    
    li $v0, 1
    move $a0, $s6
    syscall
    
    li $v0, 4
    la $a0, fecha_coluna
    syscall
    
    # Pega base do array atual
    sll $t4, $s6, 2
    add $t5, $s1, $t4
    lw $t6, 0($t5)        # $t6 = Base do Array
    
    li $s7, 0             # Índice Linha
    
loop_print_linha:
    bge $s7, $t9, prox_print_col
    
    # Pega elemento
    sll $t4, $s7, 2
    add $t8, $t6, $t4     # Endereço Elemento
    
    lwc1 $f12, 0($t8)     # Carrega Float
    li $v0, 2             # Print Float
    syscall
    
    li $v0, 4
    la $a0, separador
    syscall
    
    addi $s7, $s7, 1
    j loop_print_linha
    
prox_print_col:
    addi $s6, $s6, 1
    j loop_print_col

erro_abertura:
    li $v0, 4
    la $a0, text_abrir_falha
    syscall
    j exit

exit:
    li $v0, 10
    syscall
